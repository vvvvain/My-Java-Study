# 学习路线


<p>
  
  学习面向对象内容的三条主线  
  
- Java 类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、
abstract 等

</p>


***


<p>
  
  程序设计范式：面向对象OO、面向过程、指令式编程、函数式编程  
  
- OO：**执行者**思维，扩展能力好、后期维护较易
- 面向过程：**执行者**思维，适合简单问题、无需协作的事物，重点关注如何执行

*OO可从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程处理*

</p>



# 类和对象


## 概述

<p>
  
- OOP设计的重点是**类的设计**，其实就是**类的成员的设计**

    - 类，是一组相关属性和行为的集合，这也是类最基本的两个成员。
      
- 类是模板，对象是类的实例

- 和C语言比较:

  - 类有些像一个“主函数” = 属性(成员变量，即“类”中函数会用到的变量 <=> Field)+方法(函数=面向过程思想 <=> Method，不能脱离类而存在！)

  - 类又有些像一个“结构体” = 访问对象成员，可以用“对象名.属性”和“对象名.方法”
  
</p>


## 对象与JVM内存

- 堆 Heap：所有的对象实例，数组 👉 由此可知，和数组名类似，对象名=对象地址
  - 类、数组都是**引用数据类型**，引用数据类型的变量中存储的是对象的地址，或者说指向堆中对象的首地址
    
- 栈 Stack：局部变量，可*垃圾回收 - 方法执行完，自动释放*
  
- 方法区 Method Area：已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据


## 语法


1.定义类：关键字class

```
[修饰符] class 类名{
  属性声明
  方法声明;
}
```


2.创建对象：关键字new

```
创建对象语法：
//方式 1：给创建的对象命名
//给创建的对象添加句柄，后续可反复使用这个对象
了
  类名 对象名 = new 类名();
//方式 2：匿名对象
//直接调用对象，常作为实参传递给一个方法调用
  new 类名()
```

3.访问对象

```
  对象.属性名
  对象.方法
```


# 类的成员：成员变量field


## 定义变量

```
[修饰符1] class 类名{
  [修饰符 2] 数据类型 成员变量名 [= 初始化值];  
}
```

- 可以不赋值；
- 这是*实例/类的*成员变量，区别*方法体{}/方法的形参列表/代码块的*局部变量
- 实例变量和对象生命周期一致，局部变量和方法调用的生命一致

<img width="468" alt="1691202241055" src="https://github.com/vvvvain/My-Java-Study/assets/71417179/ba2123be-d2da-4ed2-9ac6-8b640926eedc">



# 类的成员：方法Method


## 定义方法：= 方法头 + 方法体

```
[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]{
  方法体功能代码
}
```

- 返回值：与方法体中的*return 返回值*搭配使用，方法执行结束后将结果返回到调用者
  
- 形参列表用逗号隔开：例 (数据类型 1 参数 1, 数据类型 2 参数 2)


## 方法的重载(overload)

在同一个类中，允许存在一个以上的同名方法，只要参数列表不同即可
- 参数个数或参数类型的不同


比如说，System.out.print();一族的函数

重载方法调用：JVM 通过方法的参数列表，调用匹配的方法。
– 先找个数、类型最匹配的
– 再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错


## 可变个数的形参


- 可变多个：0个，1个或多个
- 一个方法的形参中，最多声明一个可变个数的形参
- 可变形参，要放在形参声明的最后
- 可变个数形参的方法与同名方法之间，彼此构成重载
- **可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错**


```
方法名(参数的类型名 ...参数名);

//JDK 5.0 以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);

//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String...books);
```


***

### 方法的参数传递机制

- 形参(formal parameter)：定义方法时
- 实参(actual patameter)：调用方法时

- 唯一机制：值传递——将实际参数值的副本传入方法内，而参数本身不受影响
  - 形参是基本数据类型：传递“数据值”
  - 引用数据类型：“地址值”


## 调用实例方法

```
  对象.方法名([实参列表]);
```

- 方法中可以调用类中的方法/属性，但不能在方法内部再定义方法
  
- 内存
  - 未调用 - *方法区*中的字节码文件(.class)
  - 被调用- 栈内存
  - 执行结束 - 出栈，释放内存


## 递归

0.无穷递归≈死循环，最终导致栈溢出；能迭代，不用递归


1.直接递归：自身调用自身

```
public void methodA(){
  methodA();
}
```

2.间接递归：A()方法调用 B()方法，B()方法调用 C()方法，C()方法调用 A()方法

```
public static void A(){
  B();
}
public static void B(){
  C();
}
public static void C(){
  A();
}
```



# 关键字：package、import


## package


**包，用于指明该文件中定义的类、接口等结构所在的包**


```
package 顶层包名.子包名 ;

\\举例：pack1\pack2\PackageTest.java

package pack1.pack2; //指定类 PackageTest 属于包 pack1.pack2
  public class PackageTest{
  public void display(){
  System.out.println("in method display()");
  }
}
```



<p>
  
**作用**
- 可以包含类和子包，划分项目层次，便于管理
- 帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式
- 解决***类命名冲突***的问题
- 控制访问权限
  
<\p>


<p>

**说明**

- 一个源文件只能有一个声明包的 package 语句
- package 语句作为 Java 源文件的第一条语句出现。*若缺省该语句，则指定为无名包*
- 包名，全部小写、见名知意
  – 包通常使用所在公司域名的倒置：com.atguigu.xxx。
  – 取包名时不要使用"java.xx"包
- **包对应于文件系统的目录，package 语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录**
- 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）
  - **不同的包下可以定义同名的结构（类、接口）**

<\p>



<img width="463" alt="a7108c8b2422569d95856114e077241" src="https://github.com/vvvvain/My-Java-Study/assets/71417179/25ad3020-4fe6-4681-b58d-d036e2c97a0c">

<img width="450" alt="0509baeb66e35ccfaec8cbd34588b0b" src="https://github.com/vvvvain/My-Java-Study/assets/71417179/ccd527e6-36df-48e6-8203-e33e8e2218e5">



## import


为了使用定义在其它包中的 Java 类，需用 import 语句来**显式引入指定包下所需要的类**  
相当于 import 语句告诉编译器到哪里去寻找这个类

```
  import 包名.类名;
```


***


**JDK常用包简介**


java.util.Arrays - 操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法

<img width="450" alt="1691461141606" src="https://github.com/vvvvain/My-Java-Study/assets/71417179/e6cc43d0-65ee-4740-9d38-4ee7a61d58ce">




***

**注意事项**

- import 语句，声明在包的声明和类的声明之间。
- 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可
- 如果使用 a.*导入结构，表示可以导入 a 包下的所有的结构
  - 举例：可以使用java.util.*的方式，一次性导入 util 包下所有的类或接口。
- 如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此import
- 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要导入
- 如果在代码中使用不同包下的同名的类，那么就需要使用**类的全类名的方式**指明调用的是哪个类
- （了解）import static组合的使用：调用指定类或接口下的静态的属性或方法
