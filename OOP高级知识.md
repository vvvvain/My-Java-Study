# 类的成员之四：代码块

成员变量想要初始化的值不是一个硬编码的常量值，而是需要通过复杂的计算或读取文件、或读取运行环境信息等方式才能获取的一些值。



# 关键字：final

- 修饰类：不能被继承，没有子类。提高安全性和可读性
- 修饰方法：不能被子类重写
- 修饰变量：一旦赋值就不能被修改，即是常量



# 抽象类与抽象方法 & 关键字：abstract

有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类  

<p>
  
声明一些几何图形类：圆、矩形、三角形类等，发现这些类都有共同特征：求面积、求周长。那么这些共同特征应该抽取到一个共同父类：几何图形类中。但是这些方法在父类中又无法给出具体的实现，而是应该交给子类各自具体实现。那么父类在声明这些方法时，就只有方法签名，没有方法体  
我们**把没有方法体的方法称为抽象方法。Java 语法规定，包含抽象方法的类必须是抽象类；但抽象类不一定包含抽象方法**  
***注意：抽象方法不能创建对象，没有方法体，也就是一对花括号{}！！！***  
子类对父类抽象方法的实现完成，此种重写也叫做*实现方法*  
抽象类是用来被继承的，其子类必须重写父类的抽象方法，并提供方法体；若没有重写全部的抽象方法，仍为抽象类
  
<\p>

```
\\抽象类的语法格式
[权限修饰符] abstract class 类名{
}
  [权限修饰符] abstract class 类名 extends 父类{ 
}
\\抽象方法的语法格式
[其他修饰符] abstract 返回值类型 方法名([形参列表]);

```

- 不能用abstract修饰变量、代码块、构造器
- 不能用abstract修饰私有方法、静态方法、final的方法、final的类



# 接口 & 关键字：interface


Java的软件系统会有很多模块组成，各模块之间也应采用*面向接口*的*低耦合*  

接口=规范=标准，定义一组规则  

例：Java程序能否连接使用某种数据库产品，要看该产品能否实现Java设计的JDBC规范  

![P@(1{{KT7K5V4}D@4`IKAOI](https://github.com/vvvvain/My-Java-Study/assets/71417179/5612a7ec-4787-40b4-b5ca-e639ff1d2b9d)


一种引用数据类型，与类的定义类似，但是使用interface关键字，也会被编译成.class文件  

引用数据类型：数组、类、枚举、接口、注解


```
[修饰符] interface 接口名{
  // 接口的成员列表：
  // 公共的静态常量
  // 公共的抽象方法
 
  // 公共的默认方法（JDK1.8 以上）
  // 公共的静态方法（JDK1.8 以上）
  // 私有方法（JDK1.9 以上）
}
```


待补充：一些其它说明，关于多实现和多继承


![H8UH97Y2`GSS0YVMTMYR(EB](https://github.com/vvvvain/My-Java-Study/assets/71417179/cb389bcc-5e69-4862-accc-5e691cc6e9eb)




# 内部类


将一个类A定义在另一个类B里面，则A称为*内部类*，B是*外部类*   

一个完整结构A只为B服务、不在其他地方单独使用，并且B需要这个完整结构

遵循：高内聚、低耦合的OO开发原则

![BC(2Q3NERYF P%IPRS 21_Q](https://github.com/vvvvain/My-Java-Study/assets/71417179/b40a5dd9-d539-45e1-a941-c5ca8de000c0)


ps:涉及到设计模式，后面再补充吧



# 注解（Annotation）


例：@Override  

给编译器或其他程序看的“注释”  

一定程度上可以说：框架 = 注解 + 反射 + 设计模式


# 包装类
